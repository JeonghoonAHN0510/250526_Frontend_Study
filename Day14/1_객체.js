// [ 프로그래밍 관점 ]
//     - 프로그래밍을 구성하기 위한 접근 방식
//         1. 절차지향 프로그래밍 : C언어
//             1) 함수(절차)를 이용한 순서가 정해진 작업
//             2) 코드가 위에서 아래로 순차적으로 실행

//         2. 객체지향 프로그래밍 : JAVA, JS, PYTHON, C++
//             1) 객체(데이터/기능)를 하나로 묶어서 처리하는 작업
//             2) 코드의 재사용이나 확장에 유리

// [ 객체 ]
//     1. 정의
//         객체(Object)     : 주체가 아닌 다른 실체
//         주체(Subject)    : '나'라는 실체, 중심 
//     2. 생활 속 객체란? 어떠한 대상을 정의 가능한 것 = 모두
//     3. 개발자(주체) 관점에서 컴퓨터 속 기능(객체)을 만든다.

// [ JS 객체 ]
//     1. 종류
//         1) 클래스 기반 객체 : class(객체를 만들기 위한 설계도)
//         2) 클래스 없는 객체 : { }을 이용
//     2. 객체 vs 배열
//         1) 객체 : { }, 속성명 , 자료 순서 X, 정보 표현
//         2) 배열 : [ ], 인덱스 , 자료 순서 O, 목록 표현
//     * 주의할 점 : 변수는 객체와 배열 자료를 1개 저장하는 메모리 공간
//         const var1 = [ 10, 'hello' ];                       -> 자료 2개를 저장하는 '배열 자료 1개'를 변수에 저장
//         const var2 = { props1 : 10, props2 : 'hello' };     -> 자료 2개를 속성으로 구분하여 '객체 자료 1개'를 변수에 저장
//         -> 정보를 만들 때는 객체화, 동일한 정보(객체)들을 묶을 때는 배열

// [1] 객체 선언
{ }
// [2] 선언한 객체를 변수에 대입
const obj1 = { };
console.log( obj1 );    // Object(빈 객체도 객체)
// [3] 객체 선언시 속성(properties) 구성
//    - { 속성명 : 자료 }; 
//    - 속성명 + 자료 한 쌍을 entry라고 하고 , 쉼표로 구분하여 여러개 쌍을 { }로 감싼다.
//    - 속성명은 임의로 작성하되, 특수문자가 포함된 경우 "" 또는 ''로 감싼다.
//    - 속성명은 자료를 식별하는 목적으로 중복이 불가능하다.
const obj2 = { 속성명1 : 10, "속성명2" : "hello" };
console.log( obj2 );
// [4] 객체 호출
    // 변수명                                   : 전체 호출
        console.log( obj2 );                    // { 속성명1 : 10, "속성명2" : "hello" }
    // 변수명.속성명(변수명['속성명'])          : 특정한 속성의 자료 호출
        console.log( obj2.속성명1 );            // 10
        console.log( obj2['속성명2'] );         // hello
    // Object.keys( 변수명 )                    : 객체 내 모든 속성명(key)을 배열로 반환
        console.log( Object.keys( obj2 ));      // ['속성명1', '속성명2']
    // Object.values( 변수명 )                  : 객체 내 모든 자료(value)를 배열로 반환
        console.log( Object.values( obj2 ));    // [10, 'hello']
    // Object.entries( 변수명 )                 : 객체 내 모든 엔트리(entry)를 배열로 반환
        console.log( Object.entries( obj2 ));   // [['속성명1', 10], ['속성명2', 'hello']]
// [5] 객체 내 속성 추가/수정/삭제
    // 속성 추가                                : 변수명.새로운속성명 = 자료;
    obj2.속성명3 = true;
    console.log( obj2 );                        // {속성명1: 10, 속성명2: 'hello', 속성명3: true}
    // 속성 수정                                : 변수명.기존속성명 = 자료;
    obj2.속성명1 = 20;
    console.log( obj2 );                        // {속성명1: 20, 속성명2: 'hello', 속성명3: true}
    // 속성 삭제                                : delete 변수명.삭제할속성명
    delete obj2.속성명3;
    console.log( obj2 );                        // {속성명1: 20, 속성명2: 'hello'}
// [6] 객체 속성 내 자료 : 변수, 객체, 배열, 함수 등 모든 것이 들어갈 수 있다.
    let var1 = 10;
    const var2 = { props1 : 3.14, porps2 : var1, props3 : { }, props4 : [ ], props5 : function(){} };
    console.log( var2 );
// [7] in 연산자 : 객체 내 특정한 속성이 있는지 확인
    // '찾을속성명' in 변수명                   // true / false
    console.log( 'props1' in var2 );            // true
    console.log( 'props6' in var2 );            // false
// [8] 객체와 배열 조합
    // 공통점 : 여러개의 자료들을 하나의 자료로 묶는다.
    // 차이점 : 객체 - 속성명으로 자료 구분
    //          배열 - 인덱스로 자료 구분
    // 제품의 속성을 입력할 때는 객체 (서로 다른 자료의 의미를 가질 때는 객체)
const 콜라 = { '제품명' : '콜라', '가격' : 1000 };
const 사이다 = { '제품명' : '사이다', '가격' : 1500 };
    // 제품목록으로 제품을 나열할 때는 배열 (동일한 자료의 의미를 가질 때는 배열)
const 제품목록 = [ { '제품명' : '콜라', '가격' : 1000 }, { '제품명' : '사이다', '가격' : 1500 } ];
// const 제품목록 = [ 콜라, 사이다 ]
console.log( 제품목록 );
    // + 반복문 : 변수가 가지는 정보를 찾아가기( 변수명[인덱스].속성명 )
        for (let index = 0; index <= 제품목록.length - 1; index++){
            const product = 제품목록[index];        // index번째 제품
            console.log( product.제품명 );          // index번째 제품명 속성값 호출
            console.log( product.가격 );            // index번째 가격 속성값 호출
        }